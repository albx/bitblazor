@inherits TestContext

@code
{
    #region Colors tests
    [Theory]
    [InlineData(Color.Primary, "btn-primary")]
    [InlineData(Color.Secondary, "btn-secondary")]
    [InlineData(Color.Success, "btn-success")]
    [InlineData(Color.Danger, "btn-danger")]
    [InlineData(Color.Warning, "btn-warning")]
    public void BitButton_Should_Render_Button_With_Correct_Color_Class(Color color, string colorCssClass)
    {
        var component = Render(@<BitButton Color="color">Test</BitButton>);

        component.MarkupMatches(
            @<button type="button" class="btn @colorCssClass">
                Test
            </button>);
    }

    [Theory]
    [InlineData(Color.Primary, "btn-outline-primary")]
    [InlineData(Color.Secondary, "btn-outline-secondary")]
    [InlineData(Color.Success, "btn-outline-success")]
    [InlineData(Color.Danger, "btn-outline-danger")]
    [InlineData(Color.Warning, "btn-outline-warning")]
    public void BitButton_Should_Render_Button_With_Outlined_Color_Correctly(Color color, string colorCssClass)
    {
        var component = Render(@<BitButton Color="color"
                                           Variant="Variant.Outline">Test</BitButton>);

        component.MarkupMatches(
            @<button type="button" class="btn @colorCssClass">
                Test
             </button>);
    }
    #endregion

    #region Button type tests
    [Fact]
    public void BitButton_Should_Render_Button_Type_By_Default()
    {
        var component = Render(@<BitButton Color="Color.Primary">Test</BitButton>);

        component.MarkupMatches(
            @<button type="button" class="btn btn-primary">
                Test
             </button>);
    }

    [Theory]
    [InlineData(ButtonType.Button, "button")]
    [InlineData(ButtonType.Submit, "submit")]
    [InlineData(ButtonType.Reset, "reset")]
    public void BitButton_Should_Render_Button_Type_Correctly(ButtonType buttonType, string buttonTypeString)
    {
        var component = Render(@<BitButton Color="Color.Primary" Type="buttonType">Test</BitButton>);

        component.MarkupMatches(
            @<button type="@buttonTypeString" class="btn btn-primary">
                Test
             </button>);
    }
    #endregion

    #region Size tests
    [Theory]
    [InlineData(Size.Large, "btn-lg")]
    [InlineData(Size.Small, "btn-sm")]
    [InlineData(Size.Mini, "btn-xs")]
    public void BitButton_Should_Render_Button_Size_Correctly(Size size, string sizeCssClass)
    {
        var component = Render(@<BitButton Color="Color.Primary" Size="size">Test</BitButton>);

        component.MarkupMatches(
            @<button type="button" class="btn btn-primary @sizeCssClass">
                Test
             </button>);
    }
    #endregion

    #region CssClass tests
    [Fact]
    public void BitButton_Should_Render_Custom_Css_Classes_If_Specified()
    {
        var component = Render(@<BitButton Color="Color.Primary" CssClass="my-class another-class">Test</BitButton>);

        component.MarkupMatches(
            @<button type="button" class="btn btn-primary my-class another-class">
                Test
             </button>);
    }
    #endregion

    #region Disabled tests
    [Fact]
    public void BitButton_Should_Render_Disabled_Class_If_Disabled_Parameter_Is_True()
    {
        var component = Render(@<BitButton Color="Color.Primary" Disabled="true">test</BitButton>);

        component.MarkupMatches(
            @<button type="button" class="btn btn-primary disabled" disabled aria-disabled="true">
                test
             </button>);
    }
    #endregion

    #region Icon tests
    [Fact]
    public void BitButton_Should_Render_Icon_Before_Text_If_Icon_Position_Is_Start()
    {
        var component = Render(@<BitButton Color="Color.Primary"
                                           Icon="@BitBlazor.Utilities.Icons.ItStarFull"
                                           IconPosition="IconPosition.Start"><span>test</span></BitButton>);

        component.MarkupMatches(
            @<button type="button" class="btn btn-primary btn-icon">
                <svg class="icon icon-white me-1">
                    <use href="/_content/BitBlazor/bootstrap-italia/svg/sprites.svg#it-star-full" />
                </svg>
                <span>test</span>
            </button>);
    }

    [Fact]
    public void BitButton_Should_Render_Icon_After_Text_If_Icon_Position_Is_End()
    {
        var component = Render(@<BitButton Color="Color.Primary"
                                           Icon="@BitBlazor.Utilities.Icons.ItStarFull"
                                           IconPosition="IconPosition.End"><span>test</span></BitButton>);

        component.MarkupMatches(
            @<button type="button" class="btn btn-primary btn-icon">
                <span>test</span>
                <svg class="icon icon-white ms-1">
                    <use href="/_content/BitBlazor/bootstrap-italia/svg/sprites.svg#it-star-full" />
                </svg>
            </button>);
    }

    [Theory]
    [InlineData(Color.Primary, "btn-primary", "icon-primary")]
    [InlineData(Color.Secondary, "btn-secondary", "icon-secondary")]
    [InlineData(Color.Success, "btn-success", "icon-success")]
    [InlineData(Color.Warning, "btn-warning", "icon-warning")]
    [InlineData(Color.Danger, "btn-danger", "icon-danger")]
    public void BitButton_Should_Render_Icon_Rounded_Correctly(Color color, string buttonColorClass, string expectedIconColor)
    {
        var component = Render(@<BitButton Color="color"
                                           Icon="@BitBlazor.Utilities.Icons.ItStarFull"
                                           IconRounded="true"><span>test</span></BitButton>);

        component.MarkupMatches(
            @<button type="button" class="btn @buttonColorClass btn-icon">
                <span class="rounded-icon">
                    <svg class="icon @expectedIconColor">
                        <use href="/_content/BitBlazor/bootstrap-italia/svg/sprites.svg#it-star-full" />
                    </svg>
                </span>
                <span>test</span>
            </button>);
    }

    [Theory]
    [InlineData(Color.Primary, "btn-outline-primary", "icon-primary")]
    [InlineData(Color.Secondary, "btn-outline-secondary", "icon-secondary")]
    [InlineData(Color.Success, "btn-outline-success", "icon-success")]
    [InlineData(Color.Warning, "btn-outline-warning", "icon-warning")]
    [InlineData(Color.Danger, "btn-outline-danger", "icon-danger")]
    public void BitButton_Should_Render_Icon_Rounded_Correctly_With_Outline_Variant(Color color, string buttonColorClass, string expectedIconColor)
    {
        var component = Render(@<BitButton Color="color"
                                           Variant="Variant.Outline"
                                           Icon="@BitBlazor.Utilities.Icons.ItStarFull"
                                           IconRounded="true"><span>test</span></BitButton>);

        component.MarkupMatches(
            @<button type="button" class="btn @buttonColorClass btn-icon">
                <span class="rounded-icon">
                    <svg class="icon @expectedIconColor">
                        <use href="/_content/BitBlazor/bootstrap-italia/svg/sprites.svg#it-star-full" />
                    </svg>
                </span>
                <span>test</span>
            </button>);
    }

    [Theory]
    [InlineData(Color.Primary, "btn-primary", "icon-white")]
    [InlineData(Color.Secondary, "btn-secondary", "icon-white")]
    [InlineData(Color.Success, "btn-success", "icon-white")]
    [InlineData(Color.Warning, "btn-warning", "icon-white")]
    [InlineData(Color.Danger, "btn-danger", "icon-white")]
    public void BitButton_Should_Render_Icon_Color_Correctly(Color color, string buttonColorClass, string expectedIconColor)
    {
        var component = Render(@<BitButton Color="color"
                                           Icon="@BitBlazor.Utilities.Icons.ItStarFull"><span>test</span></BitButton>);

        component.MarkupMatches(
            @<button type="button" class="btn @buttonColorClass btn-icon">
                 <svg class="icon @expectedIconColor me-1">
                     <use href="/_content/BitBlazor/bootstrap-italia/svg/sprites.svg#it-star-full" />
                 </svg>
                <span>test</span>
            </button>);
    }

    [Theory]
    [InlineData(Color.Primary, "btn-outline-primary", "icon-primary")]
    [InlineData(Color.Secondary, "btn-outline-secondary", "icon-secondary")]
    [InlineData(Color.Success, "btn-outline-success", "icon-success")]
    [InlineData(Color.Warning, "btn-outline-warning", "icon-warning")]
    [InlineData(Color.Danger, "btn-outline-danger", "icon-danger")]
    public void BitButton_Should_Render_Icon_Color_Correctly_With_Outline_Variant(Color color, string buttonColorClass, string expectedIconColor)
    {
        var component = Render(@<BitButton Color="color"
                                           Variant="Variant.Outline"
                                           Icon="@BitBlazor.Utilities.Icons.ItStarFull"><span>test</span></BitButton>);

        component.MarkupMatches(
            @<button type="button" class="btn @buttonColorClass btn-icon">
                 <svg class="icon @expectedIconColor me-1">
                     <use href="/_content/BitBlazor/bootstrap-italia/svg/sprites.svg#it-star-full" />
                 </svg>
                <span>test</span>
            </button>);
    }
    #endregion

    #region Badge tests
    [Theory]
    [InlineData(Color.Primary, "btn-primary", "text-primary")]
    [InlineData(Color.Secondary, "btn-secondary", "text-secondary")]
    [InlineData(Color.Success, "btn-success", "text-success")]
    [InlineData(Color.Warning, "btn-warning", "text-warning")]
    [InlineData(Color.Danger, "btn-danger", "text-danger")]
    public void BitButton_Should_Render_Correctly_Badge_Inside(Color color, string buttonColorClass, string badgeTextClass)
    {
        var component = Render(
            @<BitButton Color="color">
                Test
                <ButtonBadge Text="9" />
             </BitButton>);

        component.MarkupMatches(
            @<button type="button" class="btn @buttonColorClass">
                Test
                <span class="badge bg-white @badgeTextClass">9</span>
             </button>);
    }

    [Theory]
    [InlineData(Color.Primary, "btn-outline-primary", "bg-primary")]
    [InlineData(Color.Secondary, "btn-outline-secondary", "bg-secondary")]
    [InlineData(Color.Success, "btn-outline-success", "bg-success")]
    [InlineData(Color.Warning, "btn-outline-warning", "bg-warning")]
    [InlineData(Color.Danger, "btn-outline-danger", "bg-danger")]
    public void BitButton_Should_Render_Correctly_Badge_Inside_With_Outline_Variant(Color color, string buttonColorClass, string badgeBackgroundClass)
    {
        var component = Render(
            @<BitButton Color="color" Variant="Variant.Outline">
                Test
                <ButtonBadge Text="9" />
             </BitButton>);

        component.MarkupMatches(
            @<button type="button" class="btn @buttonColorClass">
                Test
                <span class="badge @badgeBackgroundClass">9</span>
             </button>);
    }

    [Fact]
    public void BitButton_Should_Render_Correctly_Badge_Inside_With_Additional_Text()
    {
        var component = Render(
            @<BitButton Color="Color.Primary">
                Test
                <ButtonBadge Text="9" AdditionalText="unread messages" />
             </BitButton>);

        component.MarkupMatches(
            @<button type="button" class="btn btn-primary">
                Test
                <span class="badge bg-white text-primary">9</span>
                <span class="visually-hidden">unread messages</span>
             </button>);
    }
    #endregion
}
