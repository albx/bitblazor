@inherits BunitContext
@using System.ComponentModel.DataAnnotations

@code {
    [Fact]
    public void BitTextField_Should_Render_Default_Markup_Correctly()
    {
        string value = "value";
        var component = Render(@<BitTextField Label="label" Id="test-textfield" @bind-Value="@value"/>);

        component.MarkupMatches(
            @<div class="form-group">
                <label for="test-textfield" class="active">label</label>
                <input type="text" class="form-control" id="test-textfield" name="test-textfield" value="value" />
             </div>);
    }

    [Fact]
    public void BitTextField_Should_Render_Placeholder_Correctly()
    {
        string? value = null;
        var component = Render(
            @<BitTextField Label="label" 
                           Id="test-textfield" 
                           Placeholder="type here"
                           @bind-Value="@value"/>);

        component.MarkupMatches(
            @<div class="form-group">
                <label for="test-textfield" class="active">label</label>
                <input type="text" class="form-control" id="test-textfield" name="test-textfield" placeholder="type here" />
             </div>);
    }

    [Fact]
    public void BitTextField_Should_Set_Disabled_Correctly()
    {
        string? value = null;

        var component = Render(
            @<BitTextField Label="label" 
                           Id="test-textfield" 
                           Disabled="true"
                           @bind-Value="@value"/>);

        component.MarkupMatches(
            @<div class="form-group">
                <label for="test-textfield" class="">label</label>
                <input type="text" class="form-control" id="test-textfield" name="test-textfield" disabled />
             </div>);
    }

    [Fact]
    public void BitTextField_Should_Set_Readonly_Correctly()
    {
        string? value = "readonly";

        var component = Render(
            @<BitTextField Label="label"
                           Id="test-textfield"
                           @bind-Value="value"
                           Readonly="true"/>);

        component.MarkupMatches(
            @<div class="form-group">
                <label for="test-textfield" class="active">label</label>
                <input type="text" class="form-control" id="test-textfield" value="readonly" name="test-textfield" readonly />
             </div>);
    }

    [Fact]
    public void BitTextField_Should_Render_Plaintext_Field_Correctly()
    {
        string? value = "readonly";

        var component = Render(
            @<BitTextField Label="label"
                           Id="test-textfield"
                           @bind-Value="value"
                           Plaintext="true"/>);

        component.MarkupMatches(
            @<div class="form-group">
                <label for="test-textfield" class="active">label</label>
                <input type="text" class="form-control-plaintext" id="test-textfield" value="readonly" name="test-textfield" readonly />
             </div>);
    }

    [Theory]
    [InlineData(TextFieldType.Text, "text")]
    [InlineData(TextFieldType.Email, "email")]
    [InlineData(TextFieldType.Tel, "tel")]
    [InlineData(TextFieldType.Url, "url")]
    public void BitTextField_Should_Render_Specified_Type_Correctly(TextFieldType type, string expectedTypeString)
    {
        string? value = null;
        var component = Render(
            @<BitTextField Label="label"
                           Id="test-textfield"
                           @bind-Value="value"
                           Type="type"/>);

        component.MarkupMatches(
            @<div class="form-group">
                <label for="test-textfield" class="">label</label>
                <input type="@expectedTypeString" class="form-control" id="test-textfield" name="test-textfield" />
             </div>);
    }

    [Fact]
    public void BitTextField_Should_Render_Additional_Text_Correctly()
    {
        string? value = null;

        var component = Render(
            @<BitTextField Label="label"
                           Id="test-textfield"
                           @bind-Value="value"
                           AdditionalTextId="helper-text">
                <AdditionalText>Some text</AdditionalText>
             </BitTextField>);

        component.MarkupMatches(
            @<div class="form-group">
                <label for="test-textfield" class="">label</label>
                <input type="text" class="form-control" id="test-textfield" name="test-textfield" aria-describedby="helper-text" />
                <small id="helper-text" class="form-text">Some text</small>
             </div>);
    }

    [Fact]
    public void BitTextField_Should_Render_Correctly_Prepend_Content()
    {
        string? value = null;

        var component = Render(
            @<BitTextField Label="label"
                           Id="test-textfield"
                           @bind-Value="value">
                <PrependContent>
                    <span class="input-group-text">
                        <BitIcon IconName="@Icons.ItPencil"
                                 Size="@IconSize.Small"
                                 aria-hidden="true"/>
                    </span>
                </PrependContent>
             </BitTextField>);

        component.MarkupMatches(
            @<div class="form-group">
                <div class="input-group">
                    <span class="input-group-text"><svg class="icon icon-sm" aria-hidden="true"><use href="/_content/BitBlazor/bootstrap-italia/svg/sprites.svg#it-pencil"></use></svg></span>
                    <label for="test-textfield" class="">label</label>
                    <input type="text" class="form-control" id="test-textfield" name="test-textfield" />
                </div>
             </div>);
    }

    [Fact]
    public void BitTextField_Should_Render_Correctly_Append_Content()
    {
        string? value = null;

        var component = Render(
            @<BitTextField Label="label"
                           Id="test-textfield"
                           @bind-Value="value">
                <AppendContent>
                    <div class="input-group-append">
                        <BitButton Color="Color.Primary">
                            Send
                        </BitButton>
                    </div>
                </AppendContent>
             </BitTextField>);

        component.MarkupMatches(
            @<div class="form-group">
                <div class="input-group">
                    <label for="test-textfield" class="">label</label>
                    <input type="text" class="form-control" id="test-textfield" name="test-textfield" />
                    <div class="input-group-append">
                        <button class="btn btn-primary" type="button">Send</button>
                    </div>
                </div>
             </div>);
    }

    [Fact]
    public void BitTextField_Should_Render_Custom_Css_Class_On_Input()
    {
        string? value = null;

        var component = Render(
            @<BitTextField Label="label"
                           Id="test-textfield"
                           @bind-Value="value"
                           CssClass="custom-input"/>);

        component.MarkupMatches(
            @<div class="form-group">
                <label for="test-textfield" class="">label</label>
                <input type="text" name="test-textfield" id="test-textfield" class="form-control custom-input" />
             </div>);
    }

    [Theory]
    [InlineData(Size.Large, "form-control-lg")]
    [InlineData(Size.Small, "form-control-sm")]
    public void BitTextField_Should_Render_Size_Class_Correctly(Size size, string expectedSizeClass)
    {
        string? value = null;

        var component = Render(
            @<BitTextField Label="label"
                           Id="test-textfield"
                           @bind-Value="value"
                           Size="size"/>);

        component.MarkupMatches(
            @<div class="form-group">
                <label for="test-textfield" class="">label</label>
                <input type="text" name="test-textfield" id="test-textfield" class="form-control @expectedSizeClass" />
             </div>);
    }

    [Fact]
    public void BitTextField_Should_Not_Set_Any_Size_Class_If_Size_Parameter_Is_Set_To_Mini()
    {
        string? value = null;

        var component = Render(
            @<BitTextField Label="label"
                           Id="test-textfield"
                           @bind-Value="value"
                           Size="Size.Mini"/>);

        component.MarkupMatches(
            @<div class="form-group">
                <label for="test-textfield" class="">label</label>
                <input type="text" name="test-textfield" id="test-textfield" class="form-control" />
             </div>);
    }

    [Fact]
    public void BitTextField_Should_Show_Invalid_Class_When_Field_Has_Validation_Error()
    {
        var model = new StringValidationModel();
        var editContext = new EditContext(model);
        var submitted = false;

        var component = Render(
            @<EditForm EditContext="@editContext" OnValidSubmit="() => submitted = true">
                <DataAnnotationsValidator />
                <BitTextField Label="Name"
                              Id="test-name"
                              @bind-Value="@model.Name"
                              For="@(() => model.Name)" />
                <button type="submit" id="submit-btn">Submit</button>
             </EditForm>);

        // Trigger validation by submitting the form
        var submitButton = component.Find("#submit-btn");
        submitButton.Click();

        var input = component.Find("input#test-name");
        Assert.Contains("is-invalid", input.ClassList);
        Assert.DoesNotContain("just-validate-success-field", input.ClassList);
        Assert.False(submitted); // Form should not submit due to validation error
    }

    [Fact]
    public void BitTextField_Should_Show_Success_Class_When_Valid_Field_Is_Modified()
    {
        var model = new StringValidationModel { Name = "Valid Name" };
        var editContext = new EditContext(model);
        var submitted = false;

        var component = Render(
            @<EditForm EditContext="@editContext" OnValidSubmit="() => submitted = true">
                <DataAnnotationsValidator />
                <BitTextField Label="Name"
                              Id="test-name"
                              @bind-Value="@model.Name"
                              For="@(() => model.Name)" />
                <button type="submit" id="submit-btn">Submit</button>
             </EditForm>);

        // Trigger validation by submitting the form
        var submitButton = component.Find("#submit-btn");
        submitButton.Click();

        var input = component.Find("input#test-name");
        Assert.Contains("just-validate-success-field", input.ClassList);
        Assert.DoesNotContain("is-invalid", input.ClassList);
        Assert.True(submitted); // Form should submit successfully
    }

    [Fact]
    public void BitTextField_Should_Render_Validation_Message_With_Correct_Class()
    {
        var model = new StringValidationModel();
        var editContext = new EditContext(model);

        var component = Render(
            @<EditForm EditContext="@editContext" OnValidSubmit="() => {}">
                <DataAnnotationsValidator />
                <BitTextField Label="Name"
                              Id="test-name"
                              @bind-Value="@model.Name"
                              For="@(() => model.Name)" />
                <button type="submit" id="submit-btn">Submit</button>
             </EditForm>);

        // Trigger validation by submitting the form
        var submitButton = component.Find("#submit-btn");
        submitButton.Click();

        var validationMessage = component.Find(".just-validate-error-label");
        Assert.NotNull(validationMessage);
        Assert.Contains("Name is required", validationMessage.TextContent);
    }

    [Fact]
    public void BitTextField_Should_Not_Show_Validation_Classes_When_Field_Not_Modified()
    {
        var model = new StringValidationModel();
        var editContext = new EditContext(model);

        var component = Render(
            @<EditForm EditContext="@editContext" OnValidSubmit="() => {}">
                <DataAnnotationsValidator />
                <BitTextField Label="Name"
                              Id="test-name"
                              @bind-Value="@model.Name"
                              For="@(() => model.Name)" />
                <button type="submit" id="submit-btn">Submit</button>
             </EditForm>);

        // Do NOT submit the form - field is pristine
        var input = component.Find("input#test-name");
        Assert.DoesNotContain("is-invalid", input.ClassList);
        Assert.DoesNotContain("just-validate-success-field", input.ClassList);
    }

    // Nested test model for validation tests
    public class StringValidationModel
    {
        [Required(ErrorMessage = "Name is required")]
        [StringLength(50, MinimumLength = 3, ErrorMessage = "Name must be between 3 and 50 characters")]
        public string? Name { get; set; }
    }
}
